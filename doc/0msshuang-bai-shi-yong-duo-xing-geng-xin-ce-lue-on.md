## 求解子问题

题目要求的是`所需片段的最小数目`，我们不妨先来求它的简化版，求所给的时间片段能不能拼接成一个完整的视频。

如果能，则返回`true`，否则返回`false`。

为了最大程度上的利用子问题的解，我们可以尝试贪心或者dp算法。

先预设一个数组`dp`,`dp[i]`表示的是,仅仅根据输入的信息（clips数组）,以`i`为开始点的视频段最远可以到达哪里。

由于题目已经限制了 `0 <= clips[i][0] <= clips[i][1] <= 100`,所以数组dp的长度为101就一定够用了。

生成dp数组的代码如下：

```c++
int dp[101] ={0};
for (vector<int>& clip : clips) {
    dp[clip[0]] = max(dp[clip[0]], clip[1]);
}
```
---

第一步dp数组的生成我们可以理解为对输入的数据进行了一个整理，为了求所给的时间片段能不能拼接成一个完整的视频，之后我们可以进行以下工作：

从开始点出发，从0时刻扫描到`T`时刻，扫描过程中用mx变量来记录**当前可以到达的最远时刻**

这里我们很容易就得出扫描进行不下去的一种情况，就是`可以到达的最远时刻就等于当前时刻`

这相当于两边的路没有接上，自然无法完成该任务，返回`false`即可。

如果扫描到T时刻，则说明一路畅通，所给的视频片段能够拼成完整视频，返回`true`即可。

代码很简单，如下：

```c++
int mx = 0; // 当前可以到达的最远时间点
for (int i = 0; i < T; i++) {
    mx = max(mx, dp[i]);
    if (i == mx) return false;
}
return true;
```
---

## 引入当前最远时间pre，使用惰性更新来求解

好了，我们已经求出`所给的时间片段能不能拼接成一个完整的视频`这个子任务了，离题目要求的`需片段的最小数目`只有一步之遥。

要求这个其实很简单，可以采用贪心的思想（惰性更新）：

只要没超出上一个视频片段，我们就不引入新的片段。

如果超过了上一个视频片段，我们将引入一个`可以到达时间最远的片段`

具体的，我们使用`pre`来记录**上次引入新片段时**`可以到达时间最远的片段`

同时用`ans`来记录一共引入了多少片段。

总代码如下：

```c++
int mx = 0, ans = 0, pre = 0; // 刚开始，没有引入片段，片段数ans 和 片段最远距离pre 都为 0
for (int i = 0; i < T; i++) {
    mx = max(mx, dp[i]);
    if (i == pre) {  //这里表示上一个引入的片段已经走到了头，我们需要引入一个新片段
        ans++;  //片段数++
        pre = mx; // 引入的新片段我们不关心是那个，只关心这个片段最远能到哪
        //其实这个mx就是上次引入片段后在片段内的最大dp值，因为开始时间早于上一个引入片段的结束时间，所以一定是重叠的
    }
    if (i == mx) return -1; // 表示当前最远已经到了头，返回-1
}
return ans;
```

就比如如果`clips = [[0,5], [4,7]]， T = 7`

我们的dp数组为`dp = [5,0,0,0,7,0,0]`

当之后的算法扫描到`i=4`时，此时`mx = (mx, dp[i]) = 7`

但由于上一个时间片的最远值为5，此时还没用完，我们只更新`mx`，不更新`pre`

当`i = 5` 时，此时上一个时间片才用完毕，我们选取一个能到达最远的值来更新`pre`，同时`ans++`

完整代码：

```c++
class Solution {
public:
    int videoStitching(vector<vector<int>>& clips, int T) {
        int dp[101] ={0};
        int mx = 0, ans = 0, pre = 0;
        for (vector<int>& clip : clips) {
            dp[clip[0]] = max(dp[clip[0]], clip[1]);
        }
        for (int i = 0; i < T; i++) {
            mx = max(mx, dp[i]);
            if (i == pre) {
                ans++;
                pre = mx;
            }
            if (i == mx) return -1;
        }
        return ans;
    }
};
```
---

只有线性时间复杂度O(N+T)，0ms，双百。

原创不易，如果有帮助，点个赞就是对我最大的鼓励~~~

 [1.jpg](https://pic.leetcode-cn.com/d1dc3a5292fd328f42bdf1da7e04ea836e75176059cb04de3b99b5de4780d080-1.jpg)
