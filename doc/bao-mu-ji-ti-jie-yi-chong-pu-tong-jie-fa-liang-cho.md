#### 基础准备
本题需要一丢丢的高中概率入门基础，参考文章（了解加法法则和乘法法则即可）：
- [概率基础科普](https://blog.csdn.net/luckyzhoustar/article/details/78095876)
- [概率题](https://www.zybang.com/question/827025f27396a1205ec35efe12ec4e8f.html)


#### 21点游戏讲解

大家应该都玩过 **21 点游戏**。传统的 21 点游戏是从 54 张扑克中循环随机抽取一张牌，累计分数最先达到 21 点者获胜;超过**21点**就算爆点，就会输；如果所有玩家都没到 21 点，就选择最接近 21 点的人作为胜利者。

本题目的游戏在 21 点玩法基础上上稍微加了一点限制，比如提前设定了抽取范围区间 **[1，W]**、**在分数达到一定程度时停止抽牌**，**抽中的牌分数要求不超过指定数字等**。

按照题目意思的玩法大概是给爱丽丝 1 到 W 分数的牌，题中 W 都是 10，即给爱丽丝发 **A，2，3，4，5，6，7，8，9，10** 这十张牌，爱丽丝从中随机抽取一张，记下分数，然后将牌放回。

 [image.png](https://pic.leetcode-cn.com/6ad1558bfdbe8cff9ded2dded5742e4987e4404e4be7eedfafccc26c6b7770a7-image.png)

#### 理解题意

下面看下题目具体意思：
**「爱丽丝参与一个大致基于纸牌游戏 “21 点” 规则的游戏，描述如下：
爱丽丝以 0 分开始，」**
> 其实传统的 21 点游戏，一开始我们没有牌的时候也是 0 分，所以这一点没有疑问。

**「并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 」**
> 这句话说明 1-W 都是整数，也就是刚刚我说的那十张牌。

**「范围每次抽取都是独立的，其结果具有相同的概率。」**
> 这句话是重点，这句话说明了开头说的抽完牌之后是需要放回的。这样才能保证概率相等。

**「当爱丽丝获得不少于 K 分时，她就停止抽取数字。」抽中的牌累计大于等于 K 分时，就不再抽牌。爱丽丝的分数不超过 N 的概率是多少。」**
> 爱丽丝最后的分数要小于等于 N，求<=N 的概率。

**总结一下几个参数：
K：触发停止抽牌条件  ------   >= K 停止抽牌
N：累计分数最大值 totalMaxScore  ------  总体分数要 <=N  
W：牌面最大分数上限 singelMaxScore  ------  抽单次最多能得到的分**

本题类似于高中题目:
**「有十个球，其中白色 4 个红色 6 个，放回摸取，求摸到红球的概率是多少？--P= (1 + 1 + 1 + 1 + 1 + 1)/10 = 6/10」**  之类的问题。
>摸一个球的概率是 1/10，但是红球有 6 个所以是 6/10


#### 示例1概率计算

回忆完基础概率题之后，先看下前两个简单的示例如何着手开始算概率。

```
示例 1：
输入：N = 10, K = 1, W = 10
输出：1.00000
说明：爱丽丝得到一张卡，然后停止。
```

⬆️  同理，本题需要先求出 **<=N**的分数有几个，然后相加再✖️ 摸每张牌的概率**1/10**

> 示例 1 中，N=10，即要求累计分数<=10，由于 A-10 的牌面都不会小于 1，所以<=N 的分数有 10 个。 10/10 = 1
> 这里的 K = 1，所以任意抽中一张牌都会触发停止牌的条件。因此只需要抽一次。W=10，牌面范围还是 A-10。

#### 示例2概率计算

```
示例 2：
输入：N = 6, K = 1, W = 10
输出：0.60000
说明：爱丽丝得到一张卡，然后停止。
```
**在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。**
⬆️  同理，本题需要先求出 **<=N**的分数有几个，然后相加再✖️  摸每张牌的概率1/10
> 示例 2 中，N=6，即要求累计分数<=6，由于 A-10 的牌面<=6 的只有 6 个，所以<=N 的分数有 6 个.  6/10 = 0.6

#### **总结计算概率思路**

1. 列出所有可能出现的分数 x
2. 比较 **x** 和 **N**，计算 **x <= N** 子概率 P1，**若 x <= N，P=1；若 x > N，P1 = 0**
3. 2 中相加的可能性 * 1/W

#### 示例3概率计算
烧脑的来了，请各位坐稳扶好。
```
示例 3：
输入：N = 21, K = 17, W = 10
输出：0.73278
```
不同的是，**示例 1 和示例 2 都是只抽取了一次**，示例 3 可能抽取好几次才有**K=17**这个结果

不慌，根据上述总结的计算概率思路步骤来。
###### ---------------------------------------示例3解析 start------------------------------
由于 **K=17**, 手里分数到达  **17** 时就会停止抽牌,

也就是需要列出在手里点数最大为 16 时抽牌的 10 种可能性，即图中橙色的 17-26

因为 **W=10**，即最大牌面是**10**，所以手里点数**16**时再抽到**10 分**就会是 26 分。最大上限 26 分

在 **17-26**中，由于 **N=21**，需要算出各个分数 **<=N** 也就是 **<=21分**的概率，即图中橙色对应的蓝色部分。

因此，可以将手里的点数和概率都划分为几个部分：
1. 未到达**K 之前[0，K](即 0-16)，** 
2. **[K, N]  (即 17-21)，**
3. **[ N+1, W ]（即 22-26）**

#### 从解决一个问题开始
- **假设 16 为 x，15 即 x-1**，求爱丽丝最后的分数小于等于 16 的概率 **f(x) =  f(16) = ?**


 [image.png](https://pic.leetcode-cn.com/e8b62901d9d78b1f095b33325b3ae7460c9c25221b265ecf002875daead6e883-image.png)

#### 示例3思路
1. 列出手里可能的点数，刚刚解析了一番即**0-26**，填上**橙色格子**
2. 比较** x 和 N**，将 **17-26** 对应蓝色格子填好，**x<=N 的填上 1**，否则填 0
3. **17-26**对应蓝色格子中的概率相加，再与单次抽取牌的概率 1/10 相乘
4. 得到结果：**f(16) = 1/10 * (1  + 1 + 1  + 1 + 1 + 0 + 0 + 0 + 0 + 0) = 1/2**


 [image.png](https://pic.leetcode-cn.com/9b12b38295e4d30f126aa8d3b296b9e27f07d31d00a382baa63e2683a97c2911-image.png)

- 推导出公式：**f(x) = 1/W * (f(x+1) + f(x+2) + ... + f(x+w)) = 1/2**

图片: https://uploader.shimo.im/f/G7jvJ5he8ZIHCJsY.jpg
 [image.png](https://pic.leetcode-cn.com/0b59d27371ab4bd66013061daa1470b1cafb5a3b861f11ee00646e10bd655fbe-image.png)

**看完 f(16)，分析下 f(15):**
 [image.png](https://pic.leetcode-cn.com/2e0b689783e35029380af6b534e939ab8cc95a38c579b5c94ffa24ddf20a18e8-image.png)

**当手里点数为 15 时，最大牌面值为 10，可能累计的最大分数为 25，小于 21 点的部分是 16-21[K-1, N]**
根据推导公式：
1. f(15) = 1/10 * (1/2 + 1 + 1  + 1 + 1 + 0 + 0 + 0 + 0 + 0) 
推导得到公式：f(x-1) = 1/W * (f(x) + f(x + 1) + ... + f(x+w-1))
 [image.png](https://pic.leetcode-cn.com/1c40a6ddb52479c4b06ba6eac1c729b219903dc2cdf9943173502b0769474859-image.png)

以此类推, f(0)公式为 f(0)= 1/10 *(f(1) + f(2) + f(3) + ... + f(10)) 
 [image.png](https://pic.leetcode-cn.com/2f97a875352ddf9dcd5de217ee66a95c5635663bac0dbd89b8d0993557e1cb0a-image.png)

然而当 **x = 0**  时，f(x)就表示手里的点数为 0 时，爱丽丝多次抽牌点总分数不超过 N 也就是 21 点的概率。

因此，问题转化为求最终的 f(0)。由于已经推导出 f(x)公式

#### 代码思路
1. 初始化一个数组(**长度为K+W，包含0**)来表示**蓝色部分的概率**，**[K, N]初始化为 1，剩下初始化为 0**
2. **根据公式从 K 开始往前递推算出前一个点数对应<=21 的概率(从 K 开始递减，外层循环)**
- **设 x=16, 算出 f(16) （内层循环，无脑套公式）, 填上 16 对应的蓝色格子，然后接着往前递推 f(15)**
- **x-1=15，手里点数有 15 时，W 往前移一位，对应概率从 x 开始算到 W-1，以此类推**
3. 递推到 x=0 时，求出的 f(0)就是我们想要的结果
```
 public static double new21Game(int N, int K, int W) {
    if (K == 0){
        return 1.0;
    }
    // 初始化一个数组(长度为 K+W，包含 0)来表示蓝色部分的概率
    double f[] = new double[K + W];
    // [K, N]初始化为 1，剩下初始化为 0
    for (int i = K; i <= N; i++) {
        f[i] = 1.0;
    }
    for (int x = K - 1; x >= 0 ; x--) {
        for (int j = 0; j <= N; j++) {
            // 无脑堆公式
            double tmp = f[x + j];
            f[x] += tmp / W;
        }
    }
    return f[0];
}
```

#### 思考优化 1
 
上述答案放到官网是会超时的。因此需要优化一下。

图片: https://uploader.shimo.im/f/SdVp9jYarXL4kyiT.jpg
 [image.png](https://pic.leetcode-cn.com/a1069a332146f0ec9366ebd19a0b66697a43751fd6e793969d1897b9d5cb481f-image.png)

但是 **debug 代码 14-15 行 for中代码** 会发现⬆️ 上图中红色方框部分和绿色方框部分是有9个数字是重合的，也就是f(16)和f(15)之间有9个数字重合，以此类推，f(15)和f(14)也会有9个数字重合、f(14)和f(13)也会有9个数字重合…… 

**那么每次都需要往后计算冗余的数字，明显不符合编程思想。**

假如把最开始红色方框的十个数存起来，每次计算前一个数概率的时候，减掉最末尾的数，再加上前一个数，试一下这个方案。
以 **f(15)** 为例，**去掉末尾 W 处的 0，红色方框加上绿色方框**

 [image.png](https://pic.leetcode-cn.com/bf9936ce15c0e42fc677453fcdd4c2f287b48f2b32ca697a047afc08bf84db9d-image.png)

 [image.png](https://pic.leetcode-cn.com/90e4ce2f18b6118f5579c4a3a157b9cd3c02c3eb4993cc477d2db39169f01269-image.png)
具体代码如下：
```
public static double new21Game1(int N, int K, int W) {   
    if (K == 0){
        return 1.0;
    }
    double[] f = new double[K + W];
    for (int i = K; i <= N; i++) {
        f[i] = 1.0;
    }
    double s = N - K + 1;
    for (int x = K - 1; x >= 0; x--) {
        f[x] =  s / W;
    // 原等式便于理解：s = s - f[x + W] + f[x + 1]，下面这行原等式基础之上优化
        s += f[x] - f[x + W];
    }
    return f[0];
}
```
 [image.png](https://pic.leetcode-cn.com/6b52b9dc4d0dff7fc901f86102250e93a08507f691c097b2ff992e77e9be6a5f-image.png)

#### 思考优化 2
PS：需要看下遗忘的高中数学基础～

 [image.png](https://pic.leetcode-cn.com/46c3435b6213e7488a4796c3256cd58b52d34b0890658b944bbc2cb475c940a3-image.png)

之前推导的f(x)公式和f(x-1)的公式相减，得到：
```
f(x) - f(x-1) = 1/W * f(x+W) - 1/W * f(x)
f(x) - f(x-1) = 1/W * (f(x+W) - f(x))
f(x-1) = f(x) - 1/W * (f(x+W) - f(x))
```

代码如下：
```
public static double new21Game3(int N, int K, int W) {
    if (K == 0){
        return 1.0;
    }
    double[] f = new double[K + W];
    for (int i = K; i <= N; i++) {
        f[i] = 1.0;
    }
    // 初始化f[K - 1]即 f(16), Math.min以 N - K > W 导致概率超过1
    f[K - 1] = 1.0 * Math.min(N - K + 1, W) / W;
    for (int x = K - 1; x >= 1; x--) {
        f[x - 1] = f[x] - (f[x + W] - f[x]) / W;
    }
    return f[0];
}
```

 [image.png](https://pic.leetcode-cn.com/6c11a17cc95d76c374f2fd4ffde91b4a3361f2456f9635740c24b141fca69542-image.png)

