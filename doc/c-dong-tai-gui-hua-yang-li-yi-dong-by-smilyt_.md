### 题意
从一个数组中找到不重叠的三个子数组，每个子数组长度为k，找到三个子数组最大和，返回下标。   
最大和想一下，大概使用dp来求最优解。  

本题是返回下标，不过我们先不去关心如何找到下标，我们先关心如何找到最大的和。   
知道怎么找最大和才能找到它的下标啊。   

### dp找最大和
分析这个题中的状态，有两个，下标i和到i处已经找到子数组数目j   
所以用二维dp[i][j]来表示到下标i处已经找到的子数组为j组的最大和    
下标为i的子数组指什么呢？包含下标i处的k个元素组成的子数组  

用例子来解释dp[i][j]的含义和下标i处子数组的概念  
例：

    [1,2,1,2,6,7,5,1],k=2
    下标为0的子数组即为[1,2]
    下标为1的子数组即为[2,1]  很显然，因为不能重叠，下标0和1的子数组不能同时被选中
    dp[0][1]就是说到下标0处已经选择了1个子数组，所形成的最大和，我们很容易知道，dp[0][0]=3
    dp[1][2]就是说到下标1处已经选择了2个子数组，所形成的最大和，我们很容易知道，不可能发生这种情况
    因为假如同时选下标0和1处的子数组，会造成重叠
    到最后，我们可以知道，我们就求dp[n-k][3]
    为什么是n-k，还不是因为最后k-1个不能被选为下标，因为不够k个

弄明白dp[i][j]和下标i处子数组的概念后，我们开始算最大和。  

#### dp[0][1]->dp[n-k][3]
我们的初始状态是不是就是dp[0][1]，表示到下标0处选1个数组，用这个得到dp[n-k][3]  
需要完成两个维度上的增加，第一个是i，第二个是j  

我们分别来看，如何从dp[i]增加到dp[i+1]呢？  
**dp[i][1]->dp[i+1][1]:**  
到新的位置i+1，我们可以做两种选择，选择以i+1为下标的子数组，或者不选  
只有这两种选择。选的话，那么最大和就是以i+1为下标的子数组，不选的话，就是dp[i][1]  
这不就代表:

    dp[i+1][1]=max(以i+1为下标的子数组和,dp[i][1])

**dp[i][2]->dp[i+1][2]:**
假如想选择2个子数组，是不是最早在下标为k处，不然会有重复？  
在i+1处依然做两个选择，选择以i+1为下标的子数组，或者不选。  
选择就是以i+1为下标的子数组和+dp[i][1]，以i+1为下标子数组的和是确定的，另一个子数组的和我们要最大的  
是不是就是dp[i][1]，这个里面存储了一个子数组最大和  
不选的话，是不是就是dp[i][2]  
这不就代表：  

    dp[i+1][2]=max(以i+1为下标的子数组和+dp[i][1],dp[i][2])

**dp[i][3]->dp[i+1][3]:**
相信各位读到这里的大佬一定会了，这个方程你们自己来吧！  
它应该是这样的：

    dp[i+1][3]=max(?,?)  ?自己填

这样我们就完成了dp[0][1]->dp[n-k][3]的转化了！

### 如何得到下标呢？
从最大和得到下标，其实是很简单的，我们的dp数组原来记录的是最大和，现在我们用它记录下标，其实是一样的  
为什么呢？  
假如说现在我们在dp[i][2]处记录下标xt,yy  
那么以xt为下标子数组的和，和以yy为下标子数组的和加起来，是不是就是我们原来记录的最大和？  
每一个最大和都是由子数组得到的，而子数组可以用下标表示，所以我们记录下标就可以了  
在进行比较的时候，在把下标还原为最大和   
以i为下标子数组的最大和，我们直接用前缀和就可以算了  

假如读者明白最大和可以用下标来代替，并且自己独立完成了我留给大家完成的状态转移方程，那就可以写代码了！  

我给大家一份参考的代码，这个代码和我交的不一样，是为了让大家方便理解才写的  
没有经过测试，可能有错误  
假如发现bug请评论区留言：

```cpp

class Solution {
public:
    vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {
        int n=nums.size();
        vector<vector<vector<int>>> dp(n,vector<vector<int>>(4));

        //前缀和计算以i为下标子数组的和
        vector<int> kSum(n-k+1,0);
        int sum=0;
        for(int i=0;i<k;i++) sum+=nums[i];
        kSum[0]=sum;

        for(int i=1;i<=n-k;i++){
            sum-=nums[i-1];
            sum+=nums[i+k-1];
            kSum[i]=sum;
        }

        //初始化dp
        dp[0][1].push_back(0);
        //状态转移：dp[0][1]->dp[n-k][3]
        for(int i=1;i<=n-k;i++){
            //dp[i-1][1]->dp[i][1]
            int prev=dp[i-1][1][0];
            if(kSum[i]>kSum[prev]) dp[i][1].push_back(i);
            else dp[i][1].push_back(prev);

            //dp[i-1][2]->dp[i][2]
            if(i>=k){
                int xt=dp[i-k][1][0];
                if(dp[i-1][2].empty() || kSum[i]+kSum[xt]>kSum[dp[i-1][2][0]]+kSum[dp[i-1][2][1]]){
                    dp[i][2].push_back(xt);
                    dp[i][2].push_back(i);
                }else dp[i][2]=dp[i-1][2];
            }

            //dp[i-1][3]->dp[i-1][3]
            if(i>=2*k){
                int xt=dp[i-k][2][0];
                int yy=dp[i-k][2][1];
                if(dp[i-1][3].empty() || kSum[i]+kSum[xt]+kSum[yy]>kSum[dp[i-1][3][0]]+kSum[dp[i-1][3][1]]+kSum[dp[i-1][3][2]]){
                    dp[i][3].push_back(xt);
                    dp[i][3].push_back(yy);
                    dp[i][3].push_back(i);
                }else dp[i][3]=dp[i-1][3];
            }
        }
        return dp[n-k][3];
    }
};

```

### 总结
随意写的题解，希望能帮助到大家  
求赞  
有问题评论区提问，看到会回复  