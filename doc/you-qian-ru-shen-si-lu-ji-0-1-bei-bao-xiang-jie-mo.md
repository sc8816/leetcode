### 解题思路

**本题最重要的想法：**
    将数分为两堆，使其中一堆最为接近sum / 2, 从而转化为0-1背包问题
    将问题转化为-->石头放或不放进背包 使得背包容量最小（背包容量：sum / 2）

**为什么分为两堆**
    体中例子[2,7,4,1,8,1]
    组合 2 和 4 --> [(4 - 2),7,1,8,1]
    组合 7 和 8 --> [(4 - 2),(8 - 7),1,1]
    组合 2 和 1 --> [(4 - 2 - 1),(8 - 7), 1]
    组合 1 和 1 --> [(4 - 2 - 1),(8 - 7 - 1)]
    两堆：4，8 一堆  7，2，1，1 一堆 由此稍加思考 合理⭐🤭

**0-1背包解法**
1.传统解法（2维数组）：
    m[ i ][ j ] 表示 在面对第 i 件物品，且背包容量为 j 时所能获得的最大价值
⭐状态转移方程：
```
m[ i ][ j ]=max(m[i-1][j],m[i-1][j-w[i]]+v[i]);
```
2.滚动数组（1维数组）：
    m[ i ] 表示 剩余容量为 i 的背包所能获取的最大价值
⭐状态转移方程(与循环一同考虑)：
```
背包容量为V  v[i]为第i个物品的体积  w[i]为第i个物品的价值
⭐注意事项：背包体积由大向小循环，这样不会影响到后面的状态
j - v[i]要的是 i - 1的状态 如果从小到大则为 i 的状态    
    for(int i = 0 ; i < n ; i++)
        for(int j = V ；j >= 0 ; j--)
            m[ j ] = max(m[ j ], m[j - v[i]] + w[i]);
```

**结合本题**
本题没有价值，仅需考虑是否有剩余体积为j的背包，如果剩余体积为 j + w[i] 的背包也存在 设为1
故 背包容量为 sum / 2 每个初始设为0
⭐状态转移方程：
if(dp[j] && j + stones[i] <= sum / 2)
    dp[j + stones[i]] = 1;

欢迎批评指正！
### 代码

```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = 0;
        for(int i = 0 ; i < stones.size() ; i++)
            sum += stones[i];
        int dp[1000000];
        memset(dp,0,sizeof(dp));
        dp[0] = 1;
        for(int i = 0 ; i < stones.size() ; i++){
            for(int j = sum / 2 ; j >= 0 ; j--){
                if(dp[j] && j + stones[i] <= sum / 2){
                    dp[j + stones[i]] = 1;
                }
            }
        }
        for(int i = sum / 2 ; i >= 0 ; i--)
            if(dp[i])
                return sum - 2 * i;
        return 0;
    }
};
```